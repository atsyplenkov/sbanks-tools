# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Sbanks
                                 A QGIS plugin
 Don't Zig. Unzag
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2026-01-16
        copyright            : (C) 2026 by Anatoly Tsyplenkov
        email                : hard.sign9115@fastmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = "Anatoly Tsyplenkov"
__date__ = "2026-01-16"
__copyright__ = "(C) 2026 by Anatoly Tsyplenkov"

__revision__ = "$Format:%H$"

import os

import numpy as np

# Import from sbanks_core library
from sbanks_core.savgol import (
    smooth_open_geometry,
    smooth_closed_geometry,
)
from sbanks_core.geometry import resample_and_smooth, snap_endpoints

from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import (
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingAlgorithm,
    QgsProcessingParameterDefinition,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterNumber,
    QgsProcessingParameterBoolean,
    QgsFeature,
    QgsGeometry,
    QgsWkbTypes,
    QgsLineString,
    QgsPolygon,
    QgsMultiLineString,
    QgsMultiPolygon,
    QgsPoint,
)


class SbanksAlgorithm(QgsProcessingAlgorithm):
    """
    Savitzky-Golay filter algorithm for smoothing vector geometries.

    This algorithm applies the Savitzky-Golay filter to smooth LineString
    and Polygon geometries. It includes anti-hook logic for open geometries
    (LineStrings) and proper wrapping for closed geometries (Polygons).
    Optionally, spline-based resampling can be applied after smoothing.
    """

    INPUT = "INPUT"
    OUTPUT = "OUTPUT"
    MAX_SEGMENT_LENGTH = "MAX_SEGMENT_LENGTH"
    WINDOW_LENGTH = "WINDOW_LENGTH"
    POLYORDER = "POLYORDER"
    USE_RESAMPLING = "USE_RESAMPLING"
    SAMPLING_DISTANCE = "SAMPLING_DISTANCE"
    SMOOTHING_FACTOR = "SMOOTHING_FACTOR"

    def initAlgorithm(self, config=None):
        """Define the inputs and outputs of the algorithm."""
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr("Input layer"),
                [QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon],
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.MAX_SEGMENT_LENGTH,
                self.tr("Max segment length for densification (0 to disable)"),
                type=QgsProcessingParameterNumber.Double,
                defaultValue=60.0,
                minValue=0.0,
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.WINDOW_LENGTH,
                self.tr("Window length (must be odd)"),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=11,
                minValue=3,
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.POLYORDER,
                self.tr("Polynomial order"),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=3,
                minValue=1,
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_RESAMPLING,
                self.tr("Apply spline resampling after smoothing"),
                defaultValue=True,
            )
        )

        sampling_distance_param = QgsProcessingParameterNumber(
            self.SAMPLING_DISTANCE,
            self.tr("Resampling distance"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=25.0,
            minValue=0.001,
        )
        sampling_distance_param.setFlags(
            sampling_distance_param.flags()
            | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(sampling_distance_param)

        smoothing_factor_param = QgsProcessingParameterNumber(
            self.SMOOTHING_FACTOR,
            self.tr("Spline smoothing factor"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1.0,
            minValue=0.0,
        )
        smoothing_factor_param.setFlags(
            smoothing_factor_param.flags()
            | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(smoothing_factor_param)

        self.addParameter(
            QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr("SG smoothed layer"))
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Process the algorithm."""
        source = self.parameterAsSource(parameters, self.INPUT, context)
        max_segment_length = self.parameterAsDouble(
            parameters, self.MAX_SEGMENT_LENGTH, context
        )
        window_length = self.parameterAsInt(parameters, self.WINDOW_LENGTH, context)
        polyorder = self.parameterAsInt(parameters, self.POLYORDER, context)
        use_resampling = self.parameterAsBool(parameters, self.USE_RESAMPLING, context)
        sampling_distance = self.parameterAsDouble(
            parameters, self.SAMPLING_DISTANCE, context
        )
        smoothing_factor = self.parameterAsDouble(
            parameters, self.SMOOTHING_FACTOR, context
        )

        # Convert 0 to None (disabled)
        if max_segment_length == 0:
            max_segment_length = None

        # Validate window_length is odd
        if window_length % 2 == 0:
            window_length += 1
            feedback.pushInfo(
                self.tr(f"Window length adjusted to {window_length} (must be odd)")
            )

        # Validate polyorder < window_length
        if polyorder >= window_length:
            polyorder = window_length - 1
            feedback.pushWarning(
                self.tr(
                    f"Polynomial order adjusted to {polyorder} (must be less than window length)"
                )
            )

        # Check for geographic CRS
        if source.sourceCrs().isGeographic():
            feedback.pushWarning(
                self.tr(
                    "Input layer uses a geographic CRS. Results may be inaccurate. "
                    "Consider reprojecting to a projected CRS."
                )
            )

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            source.fields(),
            source.wkbType(),
            source.sourceCrs(),
        )

        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geom = feature.geometry()

            if geom.isNull():
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            geom_type = QgsWkbTypes.geometryType(geom.wkbType())

            # Skip Point geometries
            if geom_type == QgsWkbTypes.PointGeometry:
                feedback.pushInfo(
                    self.tr(f"Skipping point geometry for feature {feature.id()}")
                )
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            # Process the geometry
            smoothed_geom = self._smooth_geometry(
                geom,
                max_segment_length,
                window_length,
                polyorder,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                feedback,
            )

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(smoothed_geom)
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def _smooth_geometry(
        self,
        geometry,
        max_segment_length,
        window_length,
        polyorder,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        feedback,
    ):
        """
        Smooth a geometry using Savitzky-Golay filter.
        """
        geom_type = QgsWkbTypes.geometryType(geometry.wkbType())
        is_multi = QgsWkbTypes.isMultiType(geometry.wkbType())
        has_z = QgsWkbTypes.hasZ(geometry.wkbType())
        has_m = QgsWkbTypes.hasM(geometry.wkbType())

        if is_multi:
            parts = geometry.asGeometryCollection()
            smoothed_parts = []

            for part in parts:
                smoothed_part = self._smooth_single_geometry(
                    part,
                    max_segment_length,
                    window_length,
                    polyorder,
                    use_resampling,
                    sampling_distance,
                    smoothing_factor,
                    geom_type,
                    has_z,
                    has_m,
                    feedback,
                )
                if smoothed_part:
                    smoothed_parts.append(smoothed_part)

            # Reconstruct multi-geometry
            if geom_type == QgsWkbTypes.LineGeometry:
                multi_geom = QgsMultiLineString()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
            elif geom_type == QgsWkbTypes.PolygonGeometry:
                multi_geom = QgsMultiPolygon()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
        else:
            smoothed = self._smooth_single_geometry(
                geometry,
                max_segment_length,
                window_length,
                polyorder,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                geom_type,
                has_z,
                has_m,
                feedback,
            )
            if smoothed:
                return QgsGeometry(smoothed)

        return geometry

    def _smooth_single_geometry(
        self,
        geometry,
        max_segment_length,
        window_length,
        polyorder,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        geom_type,
        has_z,
        has_m,
        feedback,
    ):
        """
        Smooth a single (non-multi) geometry.
        """
        if geom_type == QgsWkbTypes.LineGeometry:
            return self._smooth_linestring(
                geometry,
                max_segment_length,
                window_length,
                polyorder,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                has_z,
                has_m,
                feedback,
            )
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return self._smooth_polygon(
                geometry,
                max_segment_length,
                window_length,
                polyorder,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                has_z,
                has_m,
                feedback,
            )
        return None

    def _smooth_linestring(
        self,
        geometry,
        max_segment_length,
        window_length,
        polyorder,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        has_z,
        has_m,
        feedback,
    ):
        """
        Smooth a LineString geometry using Savitzky-Golay filter.
        """
        line = geometry.constGet()
        if line is None:
            return None

        n_points = line.numPoints()
        if n_points < window_length:
            feedback.pushInfo(
                self.tr(
                    f"Line has fewer points ({n_points}) than window length ({window_length}). Skipping smoothing."
                )
            )
            return line.clone()

        x = np.array([line.pointN(i).x() for i in range(n_points)])
        y = np.array([line.pointN(i).y() for i in range(n_points)])

        # Store original endpoints
        x_start, y_start = x[0], y[0]
        x_end, y_end = x[-1], y[-1]

        # Apply Savitzky-Golay smoothing with anti-hook padding
        x_smooth, y_smooth = smooth_open_geometry(
            x, y, window_length, polyorder, max_segment_length=max_segment_length
        )

        # Optional resampling
        if use_resampling:
            x_smooth, y_smooth = resample_and_smooth(
                x_smooth, y_smooth, sampling_distance, smoothing_factor
            )
            # Snap endpoints after resampling
            x_smooth, y_smooth = snap_endpoints(
                x_smooth, y_smooth, x_start, y_start, x_end, y_end
            )

        # Reconstruct LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        return QgsLineString(points)

    def _smooth_polygon(
        self,
        geometry,
        max_segment_length,
        window_length,
        polyorder,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        has_z,
        has_m,
        feedback,
    ):
        """
        Smooth a Polygon geometry using Savitzky-Golay filter.
        """
        polygon = geometry.constGet()
        if polygon is None:
            return None

        exterior_ring = polygon.exteriorRing()
        if exterior_ring is None:
            return None

        smoothed_exterior = self._smooth_ring(
            exterior_ring,
            max_segment_length,
            window_length,
            polyorder,
            use_resampling,
            sampling_distance,
            smoothing_factor,
            feedback,
        )

        smoothed_interiors = []
        for i in range(polygon.numInteriorRings()):
            interior_ring = polygon.interiorRing(i)
            smoothed_interior = self._smooth_ring(
                interior_ring,
                max_segment_length,
                window_length,
                polyorder,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                feedback,
            )
            smoothed_interiors.append(smoothed_interior)

        result = QgsPolygon()
        result.setExteriorRing(smoothed_exterior)
        for interior in smoothed_interiors:
            result.addInteriorRing(interior)

        return result

    def _smooth_ring(
        self,
        ring,
        max_segment_length,
        window_length,
        polyorder,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        feedback,
    ):
        """
        Smooth a polygon ring (closed curve) using Savitzky-Golay filter.
        """
        n_points = ring.numPoints()

        if n_points < window_length + 1:
            feedback.pushInfo(
                self.tr(
                    f"Ring has fewer points ({n_points}) than window length ({window_length}). Skipping smoothing."
                )
            )
            return ring.clone()

        # Exclude the closing point (which duplicates the first)
        x = np.array([ring.pointN(i).x() for i in range(n_points - 1)])
        y = np.array([ring.pointN(i).y() for i in range(n_points - 1)])

        # Apply Savitzky-Golay smoothing with wrap mode for closed geometries
        x_smooth, y_smooth = smooth_closed_geometry(
            x, y, window_length, polyorder, max_segment_length=max_segment_length
        )

        # Optional resampling
        if use_resampling:
            # For closed rings, append first point for spline continuity
            x_closed = np.append(x_smooth, x_smooth[0])
            y_closed = np.append(y_smooth, y_smooth[0])

            x_resampled, y_resampled = resample_and_smooth(
                x_closed, y_closed, sampling_distance, smoothing_factor
            )

            x_smooth = np.asarray(x_resampled)
            y_smooth = np.asarray(y_resampled)
            if len(x_smooth) > 1:
                if (
                    abs(x_smooth[-1] - x_smooth[0]) < 1e-9
                    and abs(y_smooth[-1] - y_smooth[0]) < 1e-9
                ):
                    x_smooth = x_smooth[:-1]
                    y_smooth = y_smooth[:-1]

        # Reconstruct ring as closed LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        points.append(QgsPoint(x_smooth[0], y_smooth[0]))

        return QgsLineString(points)

    def name(self):
        """Return the algorithm name."""
        return "savgol_filter"

    def displayName(self):
        """Return the translated algorithm name."""
        return self.tr("Savitzky-Golay Filter")

    def icon(self):
        """Return the algorithm icon."""
        icon_path = os.path.join(os.path.dirname(__file__), "icon.svg")
        return QIcon(icon_path)

    def shortHelpString(self):
        """Return a short help string for the algorithm."""
        return self.tr(
            "Smooths vector geometries (LineStrings and Polygons) using the "
            "Savitzky-Golay filter.\n\n"
            "Parameters:\n"
            "- Max segment length: Densifies sparse segments before smoothing. "
            "Segments longer than this value will have points inserted via linear "
            "interpolation. This prevents spike artifacts on geometries with uneven "
            "vertex density (e.g., raster-derived polygons). Set to 0 to disable.\n"
            "- Window length: The length of the filter window (must be odd). "
            "Larger values produce smoother results.\n"
            "- Polynomial order: The order of the polynomial used to fit samples. "
            "Must be less than window length.\n"
            "- Apply spline resampling: Optionally resample the smoothed geometry "
            "using cubic spline interpolation.\n"
            "- Resampling distance: Target distance between points after resampling.\n"
            "- Spline smoothing factor: Controls the amount of smoothing applied "
            "during spline interpolation."
        )

    def tr(self, string):
        return QCoreApplication.translate("Processing", string)

    def createInstance(self):
        return SbanksAlgorithm()
