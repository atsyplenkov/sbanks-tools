# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Sbanks
                                 A QGIS plugin
 Don't Zig. Unzag
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2026-01-16
        copyright            : (C) 2026 by Anatoly Tsyplenkov
        email                : hard.sign9115@fastmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Anatoly Tsyplenkov'
__date__ = '2026-01-16'
__copyright__ = '(C) 2026 by Anatoly Tsyplenkov'

__revision__ = '$Format:%H$'

import os

import numpy as np

# Import from sbanks_core library
from sbanks_core.savgol import (
    smooth_open_geometry_arclength,
    smooth_closed_geometry_arclength,
)
from sbanks_core.geometry import resample_and_smooth, snap_endpoints

from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import (
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingAlgorithm,
    QgsProcessingParameterDefinition,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterNumber,
    QgsProcessingParameterBoolean,
    QgsFeature,
    QgsGeometry,
    QgsWkbTypes,
    QgsLineString,
    QgsPolygon,
    QgsMultiLineString,
    QgsMultiPolygon,
    QgsPoint,
)


class SbanksAlgorithm(QgsProcessingAlgorithm):
    """
    Savitzky-Golay filter algorithm for smoothing vector geometries.

    This algorithm applies the Savitzky-Golay filter to smooth LineString
    and Polygon geometries. It includes anti-hook logic for open geometries
    (LineStrings) and proper wrapping for closed geometries (Polygons).
    Optionally, spline-based resampling can be applied after smoothing.
    """

    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    WINDOW_LENGTH = 'WINDOW_LENGTH'
    POLYORDER = 'POLYORDER'
    USE_RESAMPLING = 'USE_RESAMPLING'
    SAMPLING_DISTANCE = 'SAMPLING_DISTANCE'
    SMOOTHING_FACTOR = 'SMOOTHING_FACTOR'

    def initAlgorithm(self, config=None):
        """Define the inputs and outputs of the algorithm."""
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.WINDOW_LENGTH,
                self.tr('Window length (must be odd)'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=11,
                minValue=3
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.POLYORDER,
                self.tr('Polynomial order'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=3,
                minValue=1
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_RESAMPLING,
                self.tr('Apply spline resampling after smoothing'),
                defaultValue=True
            )
        )

        sampling_distance_param = QgsProcessingParameterNumber(
            self.SAMPLING_DISTANCE,
            self.tr('Resampling distance'),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=25.0,
            minValue=0.001
        )
        sampling_distance_param.setFlags(
            sampling_distance_param.flags() | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(sampling_distance_param)

        smoothing_factor_param = QgsProcessingParameterNumber(
            self.SMOOTHING_FACTOR,
            self.tr('Spline smoothing factor'),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1.0,
            minValue=0.0
        )
        smoothing_factor_param.setFlags(
            smoothing_factor_param.flags() | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(smoothing_factor_param)

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('SG smoothed layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Process the algorithm."""
        source = self.parameterAsSource(parameters, self.INPUT, context)
        window_length = self.parameterAsInt(parameters, self.WINDOW_LENGTH, context)
        polyorder = self.parameterAsInt(parameters, self.POLYORDER, context)
        use_resampling = self.parameterAsBool(parameters, self.USE_RESAMPLING, context)
        sampling_distance = self.parameterAsDouble(parameters, self.SAMPLING_DISTANCE, context)
        smoothing_factor = self.parameterAsDouble(parameters, self.SMOOTHING_FACTOR, context)

        # Validate window_length is odd
        if window_length % 2 == 0:
            window_length += 1
            feedback.pushInfo(
                self.tr(f'Window length adjusted to {window_length} (must be odd)')
            )

        # Validate polyorder < window_length
        if polyorder >= window_length:
            polyorder = window_length - 1
            feedback.pushWarning(
                self.tr(f'Polynomial order adjusted to {polyorder} (must be less than window length)')
            )

        # Check for geographic CRS
        if source.sourceCrs().isGeographic():
            feedback.pushWarning(
                self.tr('Input layer uses a geographic CRS. Results may be inaccurate. '
                       'Consider reprojecting to a projected CRS.')
            )

        (sink, dest_id) = self.parameterAsSink(
            parameters, self.OUTPUT, context,
            source.fields(), source.wkbType(), source.sourceCrs()
        )

        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geom = feature.geometry()

            if geom.isNull():
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            geom_type = QgsWkbTypes.geometryType(geom.wkbType())

            # Skip Point geometries
            if geom_type == QgsWkbTypes.PointGeometry:
                feedback.pushInfo(
                    self.tr(f'Skipping point geometry for feature {feature.id()}')
                )
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            # Check if CRS is geographic
            is_geographic = source.sourceCrs().isGeographic()

            # Process the geometry
            smoothed_geom = self._smooth_geometry(
                geom, window_length, polyorder,
                use_resampling, sampling_distance, smoothing_factor,
                is_geographic, feedback
            )

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(smoothed_geom)
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def _smooth_geometry(self, geometry, window_length, polyorder,
                         use_resampling, sampling_distance, smoothing_factor,
                         is_geographic, feedback):
        """
        Smooth a geometry using Savitzky-Golay filter.
        """
        geom_type = QgsWkbTypes.geometryType(geometry.wkbType())
        is_multi = QgsWkbTypes.isMultiType(geometry.wkbType())
        has_z = QgsWkbTypes.hasZ(geometry.wkbType())
        has_m = QgsWkbTypes.hasM(geometry.wkbType())

        if is_multi:
            parts = geometry.asGeometryCollection()
            smoothed_parts = []

            for part in parts:
                smoothed_part = self._smooth_single_geometry(
                    part, window_length, polyorder,
                    use_resampling, sampling_distance, smoothing_factor,
                    geom_type, has_z, has_m, is_geographic, feedback
                )
                if smoothed_part:
                    smoothed_parts.append(smoothed_part)

            # Reconstruct multi-geometry
            if geom_type == QgsWkbTypes.LineGeometry:
                multi_geom = QgsMultiLineString()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
            elif geom_type == QgsWkbTypes.PolygonGeometry:
                multi_geom = QgsMultiPolygon()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
        else:
            smoothed = self._smooth_single_geometry(
                geometry, window_length, polyorder,
                use_resampling, sampling_distance, smoothing_factor,
                geom_type, has_z, has_m, is_geographic, feedback
            )
            if smoothed:
                return QgsGeometry(smoothed)

        return geometry

    def _smooth_single_geometry(self, geometry, window_length, polyorder,
                                 use_resampling, sampling_distance, smoothing_factor,
                                 geom_type, has_z, has_m, is_geographic, feedback):
        """
        Smooth a single (non-multi) geometry.
        """
        if geom_type == QgsWkbTypes.LineGeometry:
            return self._smooth_linestring(
                geometry, window_length, polyorder,
                use_resampling, sampling_distance, smoothing_factor,
                has_z, has_m, is_geographic, feedback
            )
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return self._smooth_polygon(
                geometry, window_length, polyorder,
                use_resampling, sampling_distance, smoothing_factor,
                has_z, has_m, is_geographic, feedback
            )
        return None

    def _smooth_linestring(self, geometry, window_length, polyorder,
                           use_resampling, sampling_distance, smoothing_factor,
                           has_z, has_m, is_geographic, feedback):
        """
        Smooth a LineString geometry with arc-length parameterization.
        """
        line = geometry.constGet()
        if line is None:
            return None

        n_points = line.numPoints()
        if n_points < window_length:
            feedback.pushInfo(
                self.tr(f'Line has fewer points ({n_points}) than window length ({window_length}). Skipping smoothing.')
            )
            return line.clone()

        x = np.array([line.pointN(i).x() for i in range(n_points)])
        y = np.array([line.pointN(i).y() for i in range(n_points)])

        # Store original endpoints
        x_start, y_start = x[0], y[0]
        x_end, y_end = x[-1], y[-1]

        # Use arc-length aware smoothing to avoid spike artifacts
        x_smooth, y_smooth = smooth_open_geometry_arclength(
            x, y, window_length, polyorder, is_geographic
        )

        # Optional resampling
        if use_resampling:
            x_smooth, y_smooth = resample_and_smooth(
                x_smooth, y_smooth, sampling_distance, smoothing_factor
            )
            # Snap endpoints after resampling
            x_smooth, y_smooth = snap_endpoints(
                x_smooth, y_smooth, x_start, y_start, x_end, y_end
            )

        # Reconstruct LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        return QgsLineString(points)

    def _smooth_polygon(self, geometry, window_length, polyorder,
                        use_resampling, sampling_distance, smoothing_factor,
                        has_z, has_m, is_geographic, feedback):
        """
        Smooth a Polygon geometry with arc-length parameterization.
        """
        polygon = geometry.constGet()
        if polygon is None:
            return None

        exterior_ring = polygon.exteriorRing()
        if exterior_ring is None:
            return None

        smoothed_exterior = self._smooth_ring(
            exterior_ring, window_length, polyorder,
            use_resampling, sampling_distance, smoothing_factor,
            is_geographic, feedback
        )

        smoothed_interiors = []
        for i in range(polygon.numInteriorRings()):
            interior_ring = polygon.interiorRing(i)
            smoothed_interior = self._smooth_ring(
                interior_ring, window_length, polyorder,
                use_resampling, sampling_distance, smoothing_factor,
                is_geographic, feedback
            )
            smoothed_interiors.append(smoothed_interior)

        result = QgsPolygon()
        result.setExteriorRing(smoothed_exterior)
        for interior in smoothed_interiors:
            result.addInteriorRing(interior)

        return result

    def _smooth_ring(self, ring, window_length, polyorder,
                     use_resampling, sampling_distance, smoothing_factor,
                     is_geographic, feedback):
        """
        Smooth a polygon ring (closed curve) with arc-length parameterization.
        """
        n_points = ring.numPoints()

        if n_points < window_length + 1:
            feedback.pushInfo(
                self.tr(f'Ring has fewer points ({n_points}) than window length ({window_length}). Skipping smoothing.')
            )
            return ring.clone()

        # Exclude the closing point (which duplicates the first)
        x = np.array([ring.pointN(i).x() for i in range(n_points - 1)])
        y = np.array([ring.pointN(i).y() for i in range(n_points - 1)])

        # Use arc-length aware smoothing to avoid spike artifacts
        x_smooth, y_smooth = smooth_closed_geometry_arclength(
            x, y, window_length, polyorder, is_geographic
        )

        # Optional resampling
        if use_resampling:
            # For closed rings, append first point for spline continuity
            x_closed = np.append(x_smooth, x_smooth[0])
            y_closed = np.append(y_smooth, y_smooth[0])

            x_resampled, y_resampled = resample_and_smooth(
                x_closed, y_closed, sampling_distance, smoothing_factor
            )

            x_smooth = np.asarray(x_resampled)
            y_smooth = np.asarray(y_resampled)
            if len(x_smooth) > 1:
                if (abs(x_smooth[-1] - x_smooth[0]) < 1e-9 and
                    abs(y_smooth[-1] - y_smooth[0]) < 1e-9):
                    x_smooth = x_smooth[:-1]
                    y_smooth = y_smooth[:-1]

        # Reconstruct ring as closed LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        points.append(QgsPoint(x_smooth[0], y_smooth[0]))

        return QgsLineString(points)

    def name(self):
        """Return the algorithm name."""
        return 'savgol_filter'

    def displayName(self):
        """Return the translated algorithm name."""
        return self.tr('Savitzky-Golay Filter')

    def icon(self):
        """Return the algorithm icon."""
        icon_path = os.path.join(os.path.dirname(__file__), 'icon.svg')
        return QIcon(icon_path)

    def shortHelpString(self):
        """Return a short help string for the algorithm."""
        return self.tr(
            'Smooths vector geometries (LineStrings and Polygons) using the '
            'Savitzky-Golay filter.\n\n'
            'Parameters:\n'
            '- Window length: The length of the filter window (must be odd). '
            'Larger values produce smoother results.\n'
            '- Polynomial order: The order of the polynomial used to fit samples. '
            'Must be less than window length.\n'
            '- Apply spline resampling: Optionally resample the smoothed geometry '
            'using cubic spline interpolation.\n'
            '- Resampling distance: Target distance between points after resampling.\n'
            '- Spline smoothing factor: Controls the amount of smoothing applied '
            'during spline interpolation.'
        )

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return SbanksAlgorithm()
