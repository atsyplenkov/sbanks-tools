# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Sbanks
                                 A QGIS plugin
 Don't Zig. Unzag
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2026-01-16
        copyright            : (C) 2026 by Anatoly Tsyplenkov
        email                : atsyplenkov@geogr.msu.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Anatoly Tsyplenkov'
__date__ = '2026-01-16'
__copyright__ = '(C) 2026 by Anatoly Tsyplenkov'

__revision__ = '$Format:%H$'

import os
import numpy as np

# Import from sbanks_core library
from sbanks_core.whittaker import WhittakerSmoother
from sbanks_core.geometry import (
    calculate_cumulative_distances,
    apply_antihook_padding,
    apply_ring_padding,
    resample_and_smooth,
    snap_endpoints,
)

from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.core import (
    QgsProcessing,
    QgsFeatureSink,
    QgsProcessingAlgorithm,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterNumber,
    QgsProcessingParameterBoolean,
    QgsFeature,
    QgsGeometry,
    QgsWkbTypes,
    QgsLineString,
    QgsPolygon,
    QgsMultiLineString,
    QgsMultiPolygon,
    QgsPoint,
)


class WhittakerAlgorithm(QgsProcessingAlgorithm):
    """
    Whittaker-Eilers filter algorithm for smoothing vector geometries.

    This algorithm applies the Whittaker-Eilers filter to smooth LineString
    and Polygon geometries. It uses distance-aware smoothing for better
    handling of unevenly spaced points. It includes anti-hook logic for
    open geometries (LineStrings) and proper wrapping for closed geometries
    (Polygons). Optionally, spline-based resampling can be applied after
    smoothing.
    """

    INPUT = 'INPUT'
    OUTPUT = 'OUTPUT'
    LAMBDA = 'LAMBDA'
    ORDER = 'ORDER'
    USE_RESAMPLING = 'USE_RESAMPLING'
    SAMPLING_DISTANCE = 'SAMPLING_DISTANCE'
    SMOOTHING_FACTOR = 'SMOOTHING_FACTOR'

    def initAlgorithm(self, config=None):
        """Define the inputs and outputs of the algorithm."""
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon]
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.LAMBDA,
                self.tr('Lambda (smoothing strength)'),
                type=QgsProcessingParameterNumber.Double,
                defaultValue=2e4,
                minValue=0.0
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.ORDER,
                self.tr('Derivative order for penalty'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=2,
                minValue=1,
                maxValue=4
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_RESAMPLING,
                self.tr('Apply spline resampling after smoothing'),
                defaultValue=True
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SAMPLING_DISTANCE,
                self.tr('Resampling distance'),
                type=QgsProcessingParameterNumber.Double,
                defaultValue=25.0,
                minValue=0.001
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.SMOOTHING_FACTOR,
                self.tr('Spline smoothing factor'),
                type=QgsProcessingParameterNumber.Double,
                defaultValue=1.0,
                minValue=0.0
            )
        )

        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('WE smoothed layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Process the algorithm."""
        source = self.parameterAsSource(parameters, self.INPUT, context)
        lmbda = self.parameterAsDouble(parameters, self.LAMBDA, context)
        order = self.parameterAsInt(parameters, self.ORDER, context)
        use_resampling = self.parameterAsBool(parameters, self.USE_RESAMPLING, context)
        sampling_distance = self.parameterAsDouble(parameters, self.SAMPLING_DISTANCE, context)
        smoothing_factor = self.parameterAsDouble(parameters, self.SMOOTHING_FACTOR, context)

        # Store whether we're using geographic CRS for distance calculations
        is_geographic = source.sourceCrs().isGeographic()

        (sink, dest_id) = self.parameterAsSink(
            parameters, self.OUTPUT, context,
            source.fields(), source.wkbType(), source.sourceCrs()
        )

        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geom = feature.geometry()

            if geom.isNull():
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            geom_type = QgsWkbTypes.geometryType(geom.wkbType())

            # Skip Point geometries
            if geom_type == QgsWkbTypes.PointGeometry:
                feedback.pushInfo(
                    self.tr(f'Skipping point geometry for feature {feature.id()}')
                )
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            # Process the geometry
            smoothed_geom = self._smooth_geometry(
                geom, lmbda, order,
                use_resampling, sampling_distance, smoothing_factor,
                is_geographic, feedback
            )

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(smoothed_geom)
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def _smooth_geometry(self, geometry, lmbda, order,
                         use_resampling, sampling_distance, smoothing_factor,
                         is_geographic, feedback):
        """
        Smooth a geometry using Whittaker-Eilers filter.
        """
        geom_type = QgsWkbTypes.geometryType(geometry.wkbType())
        is_multi = QgsWkbTypes.isMultiType(geometry.wkbType())
        has_z = QgsWkbTypes.hasZ(geometry.wkbType())
        has_m = QgsWkbTypes.hasM(geometry.wkbType())

        if is_multi:
            parts = geometry.asGeometryCollection()
            smoothed_parts = []

            for part in parts:
                smoothed_part = self._smooth_single_geometry(
                    part, lmbda, order,
                    use_resampling, sampling_distance, smoothing_factor,
                    geom_type, has_z, has_m, is_geographic, feedback
                )
                if smoothed_part:
                    smoothed_parts.append(smoothed_part)

            # Reconstruct multi-geometry
            if geom_type == QgsWkbTypes.LineGeometry:
                multi_geom = QgsMultiLineString()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
            elif geom_type == QgsWkbTypes.PolygonGeometry:
                multi_geom = QgsMultiPolygon()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
        else:
            smoothed = self._smooth_single_geometry(
                geometry, lmbda, order,
                use_resampling, sampling_distance, smoothing_factor,
                geom_type, has_z, has_m, is_geographic, feedback
            )
            if smoothed:
                return QgsGeometry(smoothed)

        return geometry

    def _smooth_single_geometry(self, geometry, lmbda, order,
                                 use_resampling, sampling_distance, smoothing_factor,
                                 geom_type, has_z, has_m, is_geographic, feedback):
        """
        Smooth a single (non-multi) geometry.
        """
        if geom_type == QgsWkbTypes.LineGeometry:
            return self._smooth_linestring(
                geometry, lmbda, order,
                use_resampling, sampling_distance, smoothing_factor,
                has_z, has_m, is_geographic, feedback
            )
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return self._smooth_polygon(
                geometry, lmbda, order,
                use_resampling, sampling_distance, smoothing_factor,
                has_z, has_m, is_geographic, feedback
            )
        return None

    def _smooth_linestring(self, geometry, lmbda, order,
                           use_resampling, sampling_distance, smoothing_factor,
                           has_z, has_m, is_geographic, feedback):
        """
        Smooth a LineString geometry with anti-hook extrapolation.
        """
        line = geometry.constGet()
        if line is None:
            return None

        n_points = line.numPoints()
        min_points = 5  # Minimum points needed for Whittaker smoothing
        if n_points < min_points:
            feedback.pushInfo(
                self.tr(f'Line has fewer points ({n_points}) than minimum required ({min_points}). Skipping smoothing.')
            )
            return line.clone()

        x = np.array([line.pointN(i).x() for i in range(n_points)])
        y = np.array([line.pointN(i).y() for i in range(n_points)])

        # Store original endpoints for snap-back
        x_start, y_start = x[0], y[0]
        x_end, y_end = x[-1], y[-1]

        # Calculate cumulative distances using sbanks_core
        distances = calculate_cumulative_distances(x, y, is_geographic)

        # Anti-hook padding using sbanks_core
        pad_count = max(5, n_points // 4)
        x_extended, y_extended, dist_extended = apply_antihook_padding(
            x, y, distances, pad_count
        )

        # Apply Whittaker-Eilers filter using sbanks_core
        try:
            smoother = WhittakerSmoother(
                lmbda=lmbda,
                order=order,
                data_length=len(x_extended),
                x_input=dist_extended.tolist()
            )
            x_smooth = np.array(smoother.smooth(x_extended.tolist()))
            y_smooth = np.array(smoother.smooth(y_extended.tolist()))
        except Exception as e:
            feedback.pushWarning(
                self.tr(f'Whittaker smoothing failed: {str(e)}. Returning original geometry.')
            )
            return line.clone()

        # Trim back to original range
        x_smooth = x_smooth[pad_count:-pad_count]
        y_smooth = y_smooth[pad_count:-pad_count]

        # Snap endpoints using sbanks_core
        x_smooth, y_smooth = snap_endpoints(
            x_smooth, y_smooth, x_start, y_start, x_end, y_end
        )

        # Optional resampling using sbanks_core
        if use_resampling:
            x_smooth, y_smooth = resample_and_smooth(
                x_smooth, y_smooth, sampling_distance, smoothing_factor
            )
            # Snap endpoints again after resampling
            x_smooth, y_smooth = snap_endpoints(
                x_smooth, y_smooth, x_start, y_start, x_end, y_end
            )

        # Reconstruct LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        return QgsLineString(points)

    def _smooth_polygon(self, geometry, lmbda, order,
                        use_resampling, sampling_distance, smoothing_factor,
                        has_z, has_m, is_geographic, feedback):
        """
        Smooth a Polygon geometry with wrap mode for closure.
        """
        polygon = geometry.constGet()
        if polygon is None:
            return None

        exterior_ring = polygon.exteriorRing()
        if exterior_ring is None:
            return None

        smoothed_exterior = self._smooth_ring(
            exterior_ring, lmbda, order,
            use_resampling, sampling_distance, smoothing_factor,
            is_geographic, feedback
        )

        smoothed_interiors = []
        for i in range(polygon.numInteriorRings()):
            interior_ring = polygon.interiorRing(i)
            smoothed_interior = self._smooth_ring(
                interior_ring, lmbda, order,
                use_resampling, sampling_distance, smoothing_factor,
                is_geographic, feedback
            )
            smoothed_interiors.append(smoothed_interior)

        result = QgsPolygon()
        result.setExteriorRing(smoothed_exterior)
        for interior in smoothed_interiors:
            result.addInteriorRing(interior)

        return result

    def _smooth_ring(self, ring, lmbda, order,
                     use_resampling, sampling_distance, smoothing_factor,
                     is_geographic, feedback):
        """
        Smooth a polygon ring (closed curve) using circular padding.
        """
        n_points = ring.numPoints()
        min_points = 6  # Minimum for ring (including closing point)

        if n_points < min_points:
            feedback.pushInfo(
                self.tr(f'Ring has fewer points ({n_points}) than minimum required ({min_points}). Skipping smoothing.')
            )
            return ring.clone()

        # Exclude the closing point (which duplicates the first)
        x = np.array([ring.pointN(i).x() for i in range(n_points - 1)])
        y = np.array([ring.pointN(i).y() for i in range(n_points - 1)])

        n_ring = len(x)

        # Calculate distances including the closing segment using sbanks_core
        distances = calculate_cumulative_distances(
            np.append(x, x[0]),
            np.append(y, y[0]),
            is_geographic
        )
        ring_distances = distances[:-1]
        total_perimeter = distances[-1]

        # Circular padding using sbanks_core
        pad_count = max(5, n_ring // 4)
        x_extended, y_extended, dist_extended = apply_ring_padding(
            x, y, ring_distances, pad_count, total_perimeter
        )

        # Apply Whittaker-Eilers filter using sbanks_core
        try:
            smoother = WhittakerSmoother(
                lmbda=lmbda,
                order=order,
                data_length=len(x_extended),
                x_input=dist_extended.tolist()
            )
            x_smooth = np.array(smoother.smooth(x_extended.tolist()))
            y_smooth = np.array(smoother.smooth(y_extended.tolist()))
        except Exception as e:
            feedback.pushWarning(
                self.tr(f'Whittaker smoothing failed: {str(e)}. Returning original geometry.')
            )
            return ring.clone()

        # Trim back to original range
        x_smooth = x_smooth[pad_count:-pad_count]
        y_smooth = y_smooth[pad_count:-pad_count]

        # Optional resampling using sbanks_core
        if use_resampling:
            # For closed rings, append first point for spline continuity
            x_closed = np.append(x_smooth, x_smooth[0])
            y_closed = np.append(y_smooth, y_smooth[0])

            x_resampled, y_resampled = resample_and_smooth(
                x_closed, y_closed, sampling_distance, smoothing_factor
            )

            x_smooth = np.asarray(x_resampled)
            y_smooth = np.asarray(y_resampled)
            if len(x_smooth) > 1:
                if (abs(x_smooth[-1] - x_smooth[0]) < 1e-9 and
                    abs(y_smooth[-1] - y_smooth[0]) < 1e-9):
                    x_smooth = x_smooth[:-1]
                    y_smooth = y_smooth[:-1]

        # Reconstruct ring as closed LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        points.append(QgsPoint(x_smooth[0], y_smooth[0]))

        return QgsLineString(points)

    def name(self):
        """Return the algorithm name."""
        return 'whittaker_filter'

    def displayName(self):
        """Return the translated algorithm name."""
        return self.tr('Whittaker-Eilers Filter')

    def icon(self):
        """Return the algorithm icon."""
        icon_path = os.path.join(os.path.dirname(__file__), 'icon.svg')
        return QIcon(icon_path)

    def shortHelpString(self):
        """Return a short help string for the algorithm."""
        return self.tr(
            'Smooths vector geometries (LineStrings and Polygons) using the '
            'Whittaker-Eilers filter with distance-aware smoothing.\n\n'
            'Parameters:\n'
            '- Lambda: Smoothing strength parameter. Higher values produce '
            'smoother results. Typical values range from 1e3 to 1e6.\n'
            '- Derivative order: Order of the derivative used in the penalty '
            'term (1-4). Higher orders preserve more detail.\n'
            '- Apply spline resampling: Optionally resample the smoothed geometry '
            'using cubic spline interpolation.\n'
            '- Resampling distance: Target distance between points after resampling.\n'
            '- Spline smoothing factor: Controls the amount of smoothing applied '
            'during spline interpolation.\n\n'
            'The Whittaker-Eilers filter uses the actual distances between points, '
            'making it suitable for unevenly spaced data. For geographic CRS, '
            'Haversine distances are used automatically.'
        )

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return WhittakerAlgorithm()
