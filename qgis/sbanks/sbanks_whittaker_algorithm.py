# -*- coding: utf-8 -*-

"""
/***************************************************************************
 sbanks
                                 A QGIS plugin
 Don't Zig. Unzag
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2026-01-16
        copyright            : (C) 2026 by Anatoly Tsyplenkov
        email                : hard.sign9115@fastmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = "Anatoly Tsyplenkov"
__date__ = "2026-01-16"
__copyright__ = "(C) 2026 by Anatoly Tsyplenkov"

__revision__ = "$Format:%H$"

import os

import numpy as np
from qgis.core import (
    QgsFeature,
    QgsFeatureSink,
    QgsGeometry,
    QgsLineString,
    QgsMultiLineString,
    QgsMultiPolygon,
    QgsPoint,
    QgsPolygon,
    QgsProcessing,
    QgsProcessingAlgorithm,
    QgsProcessingParameterBoolean,
    QgsProcessingParameterDefinition,
    QgsProcessingParameterFeatureSink,
    QgsProcessingParameterFeatureSource,
    QgsProcessingParameterNumber,
    QgsWkbTypes,
)
from qgis.PyQt.QtCore import QCoreApplication
from qgis.PyQt.QtGui import QIcon
from sbanks_core.geometry import (
    apply_antihook_padding,
    apply_ring_padding,
    calculate_cumulative_distances,
    resample_and_smooth,
    snap_endpoints,
)

# Import from sbanks_core library
from sbanks_core.whittaker import WhittakerSmoother


class WhittakerAlgorithm(QgsProcessingAlgorithm):
    """
    Whittaker-Eilers filter algorithm for smoothing vector geometries.

    This algorithm applies the Whittaker-Eilers filter to smooth (MULTI)LINESTRING and
    (MULTI)POLYGONS geometries. It uses distance-aware smoothing for better
    handling of unevenly spaced points. It includes anti-hook logic for
    open geometries and proper wrapping for closed geometries.
    Optionally, spline-based resampling can be applied after smoothing in
    compliance with the Savitzky-Golay smoothing (see sbanks_algorithm.py).
    """

    INPUT = "INPUT"
    OUTPUT = "OUTPUT"
    LAMBDA = "LAMBDA"
    ORDER = "ORDER"
    USE_RESAMPLING = "USE_RESAMPLING"
    SAMPLING_DISTANCE = "SAMPLING_DISTANCE"
    SMOOTHING_FACTOR = "SMOOTHING_FACTOR"

    def initAlgorithm(self, config=None):
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr("Input layer"),
                [QgsProcessing.TypeVectorLine, QgsProcessing.TypeVectorPolygon],
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.LAMBDA,
                self.tr("Lambda (smoothing strength)"),
                type=QgsProcessingParameterNumber.Double,
                defaultValue=2e4,
                minValue=0.0,
            )
        )

        self.addParameter(
            QgsProcessingParameterNumber(
                self.ORDER,
                self.tr("Derivative order for penalty"),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=2,
                minValue=1,
                maxValue=4,
            )
        )

        self.addParameter(
            QgsProcessingParameterBoolean(
                self.USE_RESAMPLING,
                self.tr("Apply spline resampling after smoothing?"),
                defaultValue=True,
            )
        )

        sampling_distance_param = QgsProcessingParameterNumber(
            self.SAMPLING_DISTANCE,
            self.tr("Resampling distance in meters"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=25.0,
            minValue=0.001,
        )
        sampling_distance_param.setFlags(
            sampling_distance_param.flags()
            | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(sampling_distance_param)

        smoothing_factor_param = QgsProcessingParameterNumber(
            self.SMOOTHING_FACTOR,
            self.tr("Spline smoothing factor"),
            type=QgsProcessingParameterNumber.Double,
            defaultValue=1.0,
            minValue=0.0,
        )
        smoothing_factor_param.setFlags(
            smoothing_factor_param.flags()
            | QgsProcessingParameterDefinition.FlagAdvanced
        )
        self.addParameter(smoothing_factor_param)

        self.addParameter(
            QgsProcessingParameterFeatureSink(self.OUTPUT, self.tr("WE smoothed layer"))
        )

    def processAlgorithm(self, parameters, context, feedback):
        """Process the algorithm."""
        source = self.parameterAsSource(parameters, self.INPUT, context)
        lmbda = self.parameterAsDouble(parameters, self.LAMBDA, context)
        order = self.parameterAsInt(parameters, self.ORDER, context)
        use_resampling = self.parameterAsBool(parameters, self.USE_RESAMPLING, context)
        sampling_distance = self.parameterAsDouble(
            parameters, self.SAMPLING_DISTANCE, context
        )
        smoothing_factor = self.parameterAsDouble(
            parameters, self.SMOOTHING_FACTOR, context
        )

        # Store whether we're using geographic CRS for distance calculations
        is_geographic = source.sourceCrs().isGeographic()

        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context,
            source.fields(),
            source.wkbType(),
            source.sourceCrs(),
        )

        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        for current, feature in enumerate(features):
            if feedback.isCanceled():
                break

            geom = feature.geometry()

            if geom.isNull():
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            geom_type = QgsWkbTypes.geometryType(geom.wkbType())

            # Skip Point geometries
            if geom_type == QgsWkbTypes.PointGeometry:
                feedback.pushInfo(
                    self.tr("Skipping point geometry for feature {}").format(
                        feature.id()
                    )
                )
                sink.addFeature(feature, QgsFeatureSink.FastInsert)
                feedback.setProgress(int(current * total))
                continue

            # Process the geometry
            smoothed_geom = self._smooth_geometry(
                geom,
                lmbda,
                order,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                is_geographic,
                feedback,
            )

            new_feature = QgsFeature(feature)
            new_feature.setGeometry(smoothed_geom)
            sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

            feedback.setProgress(int(current * total))

        return {self.OUTPUT: dest_id}

    def _smooth_geometry(
        self,
        geometry,
        lmbda,
        order,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        is_geographic,
        feedback,
    ):
        """
        Smooth a geometry using Whittaker-Eilers filter.
        """
        geom_type = QgsWkbTypes.geometryType(geometry.wkbType())
        is_multi = QgsWkbTypes.isMultiType(geometry.wkbType())
        has_z = QgsWkbTypes.hasZ(geometry.wkbType())
        has_m = QgsWkbTypes.hasM(geometry.wkbType())

        if is_multi:
            parts = geometry.asGeometryCollection()
            smoothed_parts = []

            for part in parts:
                smoothed_part = self._smooth_single_geometry(
                    part,
                    lmbda,
                    order,
                    use_resampling,
                    sampling_distance,
                    smoothing_factor,
                    geom_type,
                    has_z,
                    has_m,
                    is_geographic,
                    feedback,
                )
                if smoothed_part:
                    smoothed_parts.append(smoothed_part)

            # Reconstruct multi-geometry
            if geom_type == QgsWkbTypes.LineGeometry:
                multi_geom = QgsMultiLineString()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
            elif geom_type == QgsWkbTypes.PolygonGeometry:
                multi_geom = QgsMultiPolygon()
                for part in smoothed_parts:
                    multi_geom.addGeometry(part)
                return QgsGeometry(multi_geom)
        else:
            smoothed = self._smooth_single_geometry(
                geometry,
                lmbda,
                order,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                geom_type,
                has_z,
                has_m,
                is_geographic,
                feedback,
            )
            if smoothed:
                return QgsGeometry(smoothed)

        return geometry

    def _smooth_single_geometry(
        self,
        geometry,
        lmbda,
        order,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        geom_type,
        has_z,
        has_m,
        is_geographic,
        feedback,
    ):
        """
        Smooth a single (non-multi) geometry.
        """
        if geom_type == QgsWkbTypes.LineGeometry:
            return self._smooth_linestring(
                geometry,
                lmbda,
                order,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                has_z,
                has_m,
                is_geographic,
                feedback,
            )
        elif geom_type == QgsWkbTypes.PolygonGeometry:
            return self._smooth_polygon(
                geometry,
                lmbda,
                order,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                has_z,
                has_m,
                is_geographic,
                feedback,
            )
        return None

    def _smooth_linestring(
        self,
        geometry,
        lmbda,
        order,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        has_z,
        has_m,
        is_geographic,
        feedback,
    ):
        """
        Smooth a LineString geometry with anti-hook extrapolation.
        """
        line = geometry.constGet()
        if line is None:
            return None

        n_points = line.numPoints()
        min_points = 5  # Minimum points needed for Whittaker smoothing
        if n_points < min_points:
            feedback.pushInfo(
                self.tr(
                    "Line has fewer points ({}) than minimum required ({}). Skipping W-E smoothing."
                ).format(n_points, min_points)
            )
            return line.clone()

        x = np.array([line.pointN(i).x() for i in range(n_points)])
        y = np.array([line.pointN(i).y() for i in range(n_points)])

        # Store original endpoints for snap-back
        x_start, y_start = x[0], y[0]
        x_end, y_end = x[-1], y[-1]

        # Calculate cumulative distances using sbanks_core
        distances = calculate_cumulative_distances(x, y, is_geographic)

        # Anti-hook padding using sbanks_core
        pad_count = max(5, n_points // 4)
        x_extended, y_extended, dist_extended = apply_antihook_padding(
            x, y, distances, pad_count
        )

        # Apply Whittaker-Eilers filter using sbanks_core
        try:
            smoother = WhittakerSmoother(
                lmbda=lmbda,
                order=order,
                data_length=len(x_extended),
                x_input=dist_extended.tolist(),
            )
            x_smooth = np.array(smoother.smooth(x_extended.tolist()))
            y_smooth = np.array(smoother.smooth(y_extended.tolist()))
        except Exception as e:
            feedback.pushWarning(
                self.tr(
                    "Whittaker smoothing failed: {}. Returning original geometry."
                ).format(str(e))
            )
            return line.clone()

        # Trim back to original range
        x_smooth = x_smooth[pad_count:-pad_count]
        y_smooth = y_smooth[pad_count:-pad_count]

        # Snap endpoints using sbanks_core
        x_smooth, y_smooth = snap_endpoints(
            x_smooth, y_smooth, x_start, y_start, x_end, y_end
        )

        # Optional resampling using sbanks_core
        if use_resampling:
            x_smooth, y_smooth = resample_and_smooth(
                x_smooth, y_smooth, sampling_distance, smoothing_factor
            )
            # Snap endpoints again after resampling
            x_smooth, y_smooth = snap_endpoints(
                x_smooth, y_smooth, x_start, y_start, x_end, y_end
            )

        # Reconstruct LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        return QgsLineString(points)

    def _smooth_polygon(
        self,
        geometry,
        lmbda,
        order,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        has_z,
        has_m,
        is_geographic,
        feedback,
    ):
        """
        Smooth a Polygon geometry with wrap mode for closure.
        """
        polygon = geometry.constGet()
        if polygon is None:
            return None

        exterior_ring = polygon.exteriorRing()
        if exterior_ring is None:
            return None

        smoothed_exterior = self._smooth_ring(
            exterior_ring,
            lmbda,
            order,
            use_resampling,
            sampling_distance,
            smoothing_factor,
            is_geographic,
            feedback,
        )

        smoothed_interiors = []
        for i in range(polygon.numInteriorRings()):
            interior_ring = polygon.interiorRing(i)
            smoothed_interior = self._smooth_ring(
                interior_ring,
                lmbda,
                order,
                use_resampling,
                sampling_distance,
                smoothing_factor,
                is_geographic,
                feedback,
            )
            smoothed_interiors.append(smoothed_interior)

        result = QgsPolygon()
        result.setExteriorRing(smoothed_exterior)
        for interior in smoothed_interiors:
            result.addInteriorRing(interior)

        return result

    def _smooth_ring(
        self,
        ring,
        lmbda,
        order,
        use_resampling,
        sampling_distance,
        smoothing_factor,
        is_geographic,
        feedback,
    ):
        """
        Smooth a polygon ring (closed curve) using circular padding.
        """
        n_points = ring.numPoints()
        min_points = 6  # Minimum for ring (including closing point)

        if n_points < min_points:
            feedback.pushInfo(
                self.tr(
                    "Ring has fewer points ({}) than minimum required ({}). Skipping W-E smoothing."
                ).format(n_points, min_points)
            )
            return ring.clone()

        # Exclude the closing point (which duplicates the first)
        x = np.array([ring.pointN(i).x() for i in range(n_points - 1)])
        y = np.array([ring.pointN(i).y() for i in range(n_points - 1)])

        n_ring = len(x)

        # Calculate distances including the closing segment using sbanks_core
        distances = calculate_cumulative_distances(
            np.append(x, x[0]), np.append(y, y[0]), is_geographic
        )
        ring_distances = distances[:-1]
        total_perimeter = distances[-1]

        # Circular padding using sbanks_core
        pad_count = max(5, n_ring // 4)
        x_extended, y_extended, dist_extended = apply_ring_padding(
            x, y, ring_distances, pad_count, total_perimeter
        )

        # Apply Whittaker-Eilers filter using sbanks_core
        try:
            smoother = WhittakerSmoother(
                lmbda=lmbda,
                order=order,
                data_length=len(x_extended),
                x_input=dist_extended.tolist(),
            )
            x_smooth = np.array(smoother.smooth(x_extended.tolist()))
            y_smooth = np.array(smoother.smooth(y_extended.tolist()))
        except Exception as e:
            feedback.pushWarning(
                self.tr(
                    "Whittaker smoothing failed: {}. Returning original geometry."
                ).format(str(e))
            )
            return ring.clone()

        # Trim back to original range
        x_smooth = x_smooth[pad_count:-pad_count]
        y_smooth = y_smooth[pad_count:-pad_count]

        # Optional resampling using sbanks_core
        if use_resampling:
            # For closed rings, append first point for spline continuity
            x_closed = np.append(x_smooth, x_smooth[0])
            y_closed = np.append(y_smooth, y_smooth[0])

            x_resampled, y_resampled = resample_and_smooth(
                x_closed, y_closed, sampling_distance, smoothing_factor
            )

            x_smooth = np.asarray(x_resampled)
            y_smooth = np.asarray(y_resampled)
            if len(x_smooth) > 1:
                if (
                    abs(x_smooth[-1] - x_smooth[0]) < 1e-9
                    and abs(y_smooth[-1] - y_smooth[0]) < 1e-9
                ):
                    x_smooth = x_smooth[:-1]
                    y_smooth = y_smooth[:-1]

        # Reconstruct ring as closed LineString
        points = [QgsPoint(x_smooth[i], y_smooth[i]) for i in range(len(x_smooth))]
        points.append(QgsPoint(x_smooth[0], y_smooth[0]))

        return QgsLineString(points)

    def name(self):
        return "whittaker_filter"

    def displayName(self):
        return self.tr("Whittaker-Eilers Filter")

    def icon(self):
        icon_path = os.path.join(os.path.dirname(__file__), "icon.svg")
        return QIcon(icon_path)

    def shortHelpString(self):
        """Return a short help string for the algorithm."""
        return self.tr(
            "Smooths vector geometries (MULTI)LINESTRING and (MULTI)POLYGON using the "
            "Whittaker-Eilers filter (Eilers, 2003) with distance-aware smoothing.\n\n"
            "The Whittaker-Eilers filter uses the actual distances between vertexes, "
            "making it suitable for unevenly spaced data. For geographic CRS, "
            "Haversine distances are used automatically, otherwise the Cartesian one are used.\n"
            "<h4>Parameters:</h4>"
            "- <b>Lambda</b>: Smoothing strength parameter. Higher values produce "
            "smoother results. Typical values range from 1e3 to 1e6.\n"
            "- <b>Derivative order</b>: Order of the derivative used in the penalty "
            "term (1-4). Higher orders preserve more detail.\n"
            "<h4>Optional:</h4>"
            "- <b>Apply spline resampling</b>: Optionally resample the smoothed geometry "
            "using cubic spline interpolation following <i>Sylvester et al.</i> (2021)\n"
            "- <b>Resampling distance</b>: Target distance between points after resampling.\n"
            "- <b>Spline smoothing factor</b>: Controls the amount of smoothing applied "
            "during spline interpolation.\n"
            "<h4>References:</h4>"
            "Eilers, P. H. C. A Perfect Smoother. Anal. Chem. 75, 3631–3636 (2003).\n"
            "Sylvester, Z., Durkin, P. R., Hubbard, S. M. & Mohrig, D. Autogenic "
            "translation and counter point bar deposition in meandering rivers. "
            "GSA Bulletin 133, 2439–2456 (2021)."
        )

    def tr(self, string):
        return QCoreApplication.translate(self.__class__.__name__, string)

    def createInstance(self):
        return WhittakerAlgorithm()
